######################## IMPORTS ########################
import re

from ecom.datatypes import TypeInfo

# ------------------- PyQt Modules -------------------- #
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *

from sources.common.widgets.Widgets import ValueWidget, TypeSelector
# --------------------- Sources ----------------------- #
from sources.databases.balloondata import BalloonPackageDatabase


######################## CLASSES ########################
class ConstantEditorWidget(QWidget):
    def __init__(self, database):
        super().__init__()
        self.database = database
        self.baseTypesValues = [baseType.value for baseType in TypeInfo.BaseType]
        self.baseTypeNames = [baseType.name for baseType in TypeInfo.BaseType]

        # Constants Table
        self.constantsTable = QTableWidget(self)
        self.constantsTable.setColumnCount(4)
        self.constantsTable.setHorizontalHeaderLabels(['Name', 'Value', 'Type', 'Description'])
        self.constantsTable.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.constantsTable.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        self.constantsTable.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)
        self.constantsTable.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)
        self.constantsTable.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.populateConstantsTable()

        # Layout
        layout = QVBoxLayout(self)
        layout.addWidget(self.constantsTable)
        self.setLayout(layout)

    def populateConstantsTable(self):
        autogeneratedConstantNames = ['NUM_CONFIGURATIONS', 'DEFAULT_CONFIGURATION', 'MAX_TELECOMMAND_DATA_SIZE',
                                      'MAX_TELECOMMAND_RESPONSE_SIZE', 'MAX_CONFIG_VALUE_SIZE', ]
        defaultConstantNames = ['SYNC_BYTE_1', 'SYNC_BYTE_2']
        self.constantsTable.setRowCount(0)
        for constantName, constant in self.database.constants.items():
            if constantName not in autogeneratedConstantNames:
                disableEdit = constantName in defaultConstantNames
                baseTypeName = constant.type.baseTypeName
                if baseTypeName in self.baseTypesValues:
                    baseTypeName = self.baseTypeNames[self.baseTypesValues.index(baseTypeName)]
                self.addConstantRow(constant.name, str(constant.value), baseTypeName, constant.description, disableEdit)

    def addConstantRow(self, name, defaultValue, baseTypeName, description, disableEdit=False):
        unitNames = [unitName for unitName, unitVariants in self.database.units.items()]
        rowPosition = self.constantsTable.rowCount()
        self.constantsTable.insertRow(rowPosition)
        # CONSTANT NAME
        if disableEdit:
            nameWidget = QLabel(name)
            self.constantsTable.setCellWidget(rowPosition, 0, nameWidget)
        else:
            nameItem = QTableWidgetItem(name)
            self.constantsTable.setItem(rowPosition, 0, nameItem)
        # VALUE ENTRY
        matchingArrayFormat = re.search(r'(.*?)\[(.*?)\]', baseTypeName)
        if matchingArrayFormat:
            baseTypeName, arraySize = matchingArrayFormat.group(1), int(matchingArrayFormat.group(2))
        else:
            arraySize = 1
        if baseTypeName not in self.baseTypeNames:
            if baseTypeName in unitNames:
                baseTypeUnitValue = self.database.units[baseTypeName][0].baseTypeName
                valueWidget = ValueWidget(cType=baseTypeUnitValue, value=defaultValue, arraySize=arraySize)
                valueWidget.valueChanged.connect(self.changingValue)
            else:
                valueWidget = ValueWidget(cType=baseTypeName, value=defaultValue, arraySize=arraySize)
                valueWidget.valueChanged.connect(self.changingValue)
        else:
            baseTypeValue = self.baseTypesValues[self.baseTypeNames.index(baseTypeName)]
            valueWidget = ValueWidget(cType=baseTypeValue, value=defaultValue, arraySize=arraySize)
            valueWidget.valueChanged.connect(self.changingValue)
        self.constantsTable.setCellWidget(rowPosition, 1, valueWidget)
        # BASE TYPE BUTTON
        baseTypeButton = QPushButton(baseTypeName)
        if not self.isTypeValid(baseTypeName):
            baseTypeButton.setStyleSheet('QPushButton {color: red;}')
        baseTypeButton.clicked.connect(self.changeConstantType)
        self.constantsTable.setCellWidget(rowPosition, 2, baseTypeButton)
        # CONSTANT DESCRIPTION
        descriptionItem = QTableWidgetItem(description)
        self.constantsTable.setItem(rowPosition, 3, descriptionItem)

    def changeConstantType(self):
        senderWidget: QPushButton = self.sender()
        baseType = senderWidget.text()
        row = self.constantsTable.indexAt(senderWidget.pos()).row()
        dialog = TypeSelector(self.database, baseType)
        result = dialog.exec_()
        if result == QDialog.Accepted:
            selectedType = dialog.selectedType
            configType = f'{selectedType[0]}[{selectedType[2]}]' if selectedType[1] else f'{selectedType[0]}'
            print(configType)

    def changingValue(self):
        print('changing value')
        pass

    def isTypeValid(self, baseTypeName):
        unitNames = [unitName for unitName, unitVariants in self.database.units.items()]
        acceptedTypes = self.baseTypeNames + self.baseTypesValues + unitNames + self.database.getSharedDataTypes()
        matchingArrayFormat = re.search(r'(.*?)\[(.*?)\]', baseTypeName)
        if matchingArrayFormat:
            typeName, arraySize = matchingArrayFormat.group(1), matchingArrayFormat.group(2)
            return typeName in acceptedTypes and arraySize.isdigit()
        else:
            return baseTypeName in acceptedTypes
